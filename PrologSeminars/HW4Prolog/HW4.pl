/*
   HW:
   1. Да се напише предикат binary(L), генериращ в L всички двоични дървета, като:
   - [] е двойчно дърво;
   - ако А и В са двойчни дървета, то и [A, B] е двойчно дърво.
   2. Да се дефинира предикат p(L, R), който генерира в R всички списъци с елемнти от L.
   3. Да се напише предикат p(N), генериращ ввсички числа от вида ai + bj:
   |a0 = 1						|b0 = 7
   |aN = 3*a(N - 1) + n 		|bN = 3b(N - 1) + n^2 - 1
   4. Да се напише предикат генериращ всички числа между 0 и 1000, които са от следния вид 8*(n+11)^5 * (19 + k)^2
   5. Да се напише предикат, които "пакетира" елементите в списък L. прим: [1,2,2,1,4,5,5,5] -> [[1], [2,2], [1], [4], [5,5,5]].
*/

% 1.
nat(0).
nat(N):- nat(M), N is M + 1.

between(A, B, A):- A =< B.
between(A, B, R):- A < B, A1 is A - 1, between(A1, B, R).

pairs(A, B):- nat(N), between(0, N, A), B is N - A.

binary(T):- nat(N), worker(N, T).

worker(0, []).
worker(N, [T1,T2]):- N > 0, N1 is N - 1, between(0, N1, NT1),
		NT2 is N1 - NT1, worker(NT1, T1), worker(NT2, T2).

% 2.
p(_, []).
p(L, [H|T]):- p(L, T), member(H, L). 

% 3.
a(0, 1).
a(N, R):- N > 0, N1 is N - 1, a(N1, R1), R is 3 * R1 + N.

b(0, 7).
b(N, R):- N > 0, N1 is N - 1, b(N1, R1), R is 3 * R1 + N^2 - 1.

p1(X):- pairs(A, B), a(A, R1), b(B, R2), X is R1 + R2.

% 4.
p2(X):- between(0, 1000, Y), between(0, 1000, Z), X is 8 * (Y + 11)^5 * (19 + Z)^2, X >= 0, X < 1000.

% 5.
pack([], []).
pack([A], [[A]]).
pack([A, A|T], [[A|C]|R]):- pack([A|T], [C|R]).
pack([B, A|T], [[B]|R]):- A \= B, pack([A|T], R).