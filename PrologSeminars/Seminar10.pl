% 1.
/*
	21 ноември 2015 г.
	Зад. 2. Нека E е списък от двуелементни списъци като всеки
	двуелементен списък [u,v] интерпретираме като ребро от връх u
	към v в граф. Да се дефинират на Пролог следните предикати:
	∙ p(E), който разпознава дали зададеният с E граф е цик-
	личен. Един граф е цикличен, ако ребрата му образуват
	цикъл, в който през всяко ребро и през всеки връх се ми-
	нава точно по веднъж.
	∙ q(E), който разпознава дали зададеният с G граф е ос-
	морка. Един граф е осморка, ако е обединение на два цик-
	лични графа, които имат точно един общ връх помежду
	си.
	Заб.: Граф, който е осморка, може така да се разположи в рав-
	нината, че да изписва цифрата осем.

	∙ q(E), който разпознава дали зададеният с G граф е три-
	листна детелина. Един граф е трилистна детелина, ако
	е обединение на три циклични графа, които имат точно
	един общ връх и никои два от тях нямат друг общ връх.
	Заб.: Граф, който е трилистна детелина, може така да се разпо-
	ложи в равнината, че да изобразява трилистна детелина.


	За да разберем дали един граф е цикличен, то трябва да направим пермутация на върховете и да проверим:
	- дали започва и завършва в същия връх
	- да няма връх, от който да излиза повече от едно ребро т.е. да няма вътрешен цикъл
	- и все пак да е коректен цикъла, т.е. [[..., [u, v], [v, w], ...]]
*/
/*			
?- p([[a,b],[b,c],[c,a]]).
true ;
true ;
true ;
false.

?- p([[a,b],[b,c],[c,a], [c, e]]).
false.
*/

% Ще ми трябва да знам началния връх за втората подточка.
p1(E, S):- permutation(E, P), P = [[S,_]|_], append(_, [[_, S]], P), 
			not(( append(_, [[X, _]|T], P), member([X, _], T) )),
 			not(( append(_, [[_, U], [V, _]|T], P), U \= V )).
/*
?- p1([[a,b],[b,c],[c,a]], S).
S = a ;
S = b ;
S = c ;
false.
*/

q(E):- split2(E, L, R), p1(L, S), p1(R, S), print(S), print(L), print(R). % осморка
/*
?- q([[a,b],[b,c],[c,a], [a, d], [d, e], [e, a]]).
a[[a,b],[b,c],[c,a]][[a,d],[d,e],[e,a]]
true ;
a[[a,d],[d,e],[e,a]][[a,b],[b,c],[c,a]]
true ;
false.

?- q([[a,b],[b,c],[c,a]]).
false.
*/

% Помощна функция - разбива списъка L на два списъка
split2([], [], []).
split2([H|T], [H|L], R):- split2(T, L, R).
split2([H|T], L, [H|R]):- split2(T, L, R).
/*
?- split2([a, b, c], L, R).
L = [a, b, c],
R = [] ;
L = [a, b],
R = [c] ;
L = [a, c],
R = [b] ;
L = [a],
R = [b, c] ;
--------------------------- Огледални са
L = [b, c],
R = [a] ;
L = [b],
R = [a, c] ;
L = [c],
R = [a, b] ;
L = [],
R = [a, b, c].

	Не ви ли прилича мноооого на subset(L, X)?
	Реално ви върши работа за две задачи:
	- да намерите всички подсписъци ("подмножества")
	- да разбиете даден списък на 2 подсписъка - негови подмножества
?- split2([a, b, c], L, _).
L = [a, b, c] ;
L = [a, b] ;
L = [a, c] ;
L = [a] ;
L = [b, c] ;
L = [b] ;
L = [c] ;
L = [].
*/

q1(E):- split3(E, L, M, R), p1(L, S), p1(M, S), p1(R, S), print(S), print(L), print(M), print(R). % детелина
/*
?- q1([[a,b],[b,c],[c,a], [a, d], [d, e], [e, a]]).
false.

?- q1([[a,b],[b,c],[c,a], [a, d], [d, e], [e, a], [a, o], [o, p], [p, a]]).
a[[a,b],[b,c],[c,a]][[a,d],[d,e],[e,a]][[a,o],[o,p],[p,a]]
true ;
a[[a,b],[b,c],[c,a]][[a,o],[o,p],[p,a]][[a,d],[d,e],[e,a]]
true ;
a[[a,d],[d,e],[e,a]][[a,b],[b,c],[c,a]][[a,o],[o,p],[p,a]]
true ;
a[[a,o],[o,p],[p,a]][[a,b],[b,c],[c,a]][[a,d],[d,e],[e,a]]
true ;
a[[a,d],[d,e],[e,a]][[a,o],[o,p],[p,a]][[a,b],[b,c],[c,a]]
true ;
a[[a,o],[o,p],[p,a]][[a,d],[d,e],[e,a]][[a,b],[b,c],[c,a]]
true ;
false. Пермутация на 3 елемента. 3! = 6 отговора.
*/


% Помощна функция - разбива списъка L на три списъка
split3([], [], [], []).
split3([H|T], [H|L], M, R):- split3(T, L, M, R).
split3([H|T], L, [H|M], R):- split3(T, L, M, R).
split3([H|T], L, M, [H|R]):- split3(T, L, M, R).




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Генератори - предикати с безброи много изводи
% Безкрайните генератори не служат за разпознаватели.
% Примерно nat(8).
/*
?- nat(8).
true ;
^CAction (h for help) ? break
% Break level 1
[1]  ?-
Както виждате намери го, но при преудовлетворяване зацикля.
*/
% 1. Генератор на естествени числа
nat(0).
nat(N):- nat(M), N is M + 1.


% На този принцип работи и генератора на кратни на N числа.
div_gen(0, _).
div_gen(X, N):- div_gen(Y, N), X is Y + N.
/*
					  nat(X)
					/ 1)  \ 2);
				X = 0	    nat(X1), X is X1 + 1
							/ 1)  \ 2)
						  X1 = 0	nat(X2), X1 is X2 + 1
						  X = 1      / 1)           \ 2)
						            X2 = 0			...
						            X1 = 1
						            X = 2
?- nat(X).
X = 0 ;
X = 1 ;
X = 2 ;
X = 3 ;
X = 4 ;
X = 5 ;
X = 6 ;
X = 7 ;
....
*/

integer(0, 0).
integer(X, Y):- X > 0, (Y is X; Y is -X).
/*
?- integer(7, Y).
Y = 7 ;
Y = -7.
*/

% 2. Краен генератор на цели числа в интервала [A,B]
between(A, B, A):- A =< B.
between(A, B, R):- A < B, A1 is A + 1, between(A1, B, R).
/*
?- between(1, 8, 7).
true ;
false.
?- between(1, 8, 9).
false.
Разликата с безкрайния генератор. Намира го и след това при преудовлетворяване не се озоваваме в безкрайно търсене.
*/
/*
?- between(0,10,X).
X = 0 ;
X = 1 ;
X = 2 ;
X = 3 ;
X = 4 ;
X = 5 ;
X = 6 ;
X = 7 ;
X = 8 ;
X = 9 ;
X = 10 ;
false.
*/

range(A, A, [A]).
range(A, B, [A|R]):- A < B, A1 is A + 1, range(A1, B, R).
/*
?- range(0,10, L).
L = [0, 1, 2, 3, 4, 5, 6, 7, 8|...] [write]
L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ;
false.
*/

% 3. Генератор на двойки числа
pairs(A, B):- nat(N), between(0, N, A), B is N - A.
/*
?-
|    pairs(X, Y).
X = Y, Y = 0 ;
X = Y, Y = 0 ;
X = 0,
Y = 1 ;
X = 1,
Y = 0 ;
X = 1,
Y = 0 ;;
X = 0,
Y = 1 ;
X = 1,
Y = 0 ;
X = 1,
Y = 0 ;
X = 0,
Y = 2;
.....
*/

% 4. Генератор на K числа със сума S
genKS(1, S, [S]).
genKS(K, S, [Curr|Result]):- K > 1, K1 is K - 1, 
	between(0, S, Curr), S1 is S - Curr, genKS(K1, S1, Result).
/*
Комбинации с повторение
Брой решения е Binomial(S + (K - 1), K - 1) 

?- genKS(2,5,X).
X = [0, 5] ;
X = [1, 4] ;
X = [2, 3] ;
X = [3, 2] ;
X = [4, 1] ;
X = [5, 0] ;
X = [5, 0] ;
X = [4, 1] ;
X = [5, 0] ;
X = [5, 0] ;
X = [3, 2] ;
X = [4, 1] ;
X = [5, 0] ;
X = [5, 0] ;
X = [4, 1] ;
...
*/
% Следващото "решение" няма да ни доведе до свестен отговор:
pairs2(A, B):- nat(A), nat(B).
% Ще циклим на [0, X] за 0 <= X <= Inf.
% Но защо например не направим
pairs1(A, B):- nat(N), between(0, N, A), between(0, N, B).
/* Toooooo much повторения вече на всяка двойка.
?- pairs2(X,Y).
X = Y, Y = 0 ;
X = Y, Y = 0 ;
X = Y, Y = 0 ;
X = Y, Y = 0 ;
X = Y, Y = 0 ;
X = 0,
Y = 1 ;
X = 0,
Y = 1 ;
X = Y, Y = 0 ;
X = 0,
Y = 1 ;
X = 0,
Y = 1 ;
X = 1,
Y = 0 ;
X = Y, Y = 1 ;
X = Y, Y = 1 ;
X = 1,
Y = 0 ;
X = Y, Y = 1 ;
X = Y, Y = 1 ;
X = 1,
Y = 0
*/

% 5. Генератор на всички крайни редици от естествени числа (неизброимо много).
genAll([]).
genAll(L):- nat(N), between(1, N, K),
			 S is N - K, genKS(K, S, L).

% 6. Числата на Фибоначи
fib(0, 1).
fib(Y, Z):- fib(X, Y), Z is X + Y.
fib(X):- fib(X, _).
/*

?- fib(X).
X = 0 ;
X = 1 ;
X = 1 ;
X = 2 ;
X = 3 ;
X = 5 ;
X = 8 ;
...
*/

% 7. splitGen генератор
split([], []).
split(L, [H|R]):- append(H, T, L), H \= [], split(T, R).
/*
?- split([1,2,3],L).
L = [[1], [2], [3]] ;
L = [[1], [2, 3]] ;
L = [[1, 2], [3]] ;
L = [[1, 2, 3]] ;
false.
*/
% Просто слагаме елементите ни в още списъци.
splitN(0, L, L).
splitN(K, L, R):- K > 0, K1 is K - 1, split(L, T), splitN(K1, T, R).
/*
?- splitN(2, [1,2,3], L).
L = [[[1]], [[2]], [[3]]] ;
L = [[[1]], [[2], [3]]] ;
L = [[[1], [2]], [[3]]] ;
L = [[[1], [2], [3]]] ;
L = [[[1]], [[2, 3]]] ;
L = [[[1], [2, 3]]] ;
L = [[[1, 2]], [[3]]] ;
L = [[[1, 2], [3]]] ;
L = [[[1, 2, 3]]] ;
	Окей нека да си представим нещата по-различно.
	Още сме на случая K = 2 тогава split([1,2,3], [[1], [2], [3]]) ни връща.
	Нека a = [1], b = [2], c = [3], т.е. имаме списък от [a, b, c].
	Продължаваме с splitN(1, [a, b, c], R).
	За К = 1 тогава split([a,b,c], [[a], [b], [c]]) и продължаваме с splitN(0, [[a], [b], [c]], R).
	Стигаме до дъното К = 0 и връщаме този списък [[a], [b], [c]] -> [[[1]], [[2]], [[3]]].
	Нека разгледаме и случая, когато L = [[[1, 2], [3]]].
	За K = 2 split([1,2,3], [[1, 2], [3]]) и нека a = [1, 2], а b = [3].
	Продължаваме с splitN(1, [a, b], R).
	За K = 1 split([a, b], [[a, b]]) ( Коректно е на предна стъпка сме генерирали [[a], [b]])
	Викаме след това splitN(0, [[a, b]], R).
	Стигаме до дъното К = 0 и връщаме този списък [[a, b]] -> [[[1, 2], [3]]].
	Т.е. много по-разбираемо е, ако на всяко ниво резултатът го заместваме с някаква буквичка, защото
	много скоби ни пречи на това да разберем какво всъщност прави този предикат.
	После като заместим всички получаваме търсения израз.

?- splitN(5, [1,2,3], L).
L = [[[[[[1]]]]], [[[[[2]]]]], [[[[[3]]]]]] ;
L = [[[[[[1]]]]], [[[[[2]]]], [[[[3]]]]]] ;
L = [[[[[[1]]]], [[[[2]]]]], [[[[[3]]]]]] ;
L = [[[[[[1]]]], [[[[2]]]], [[[[3]]]]]] ;
L = [[[[[[1]]]]], [[[[[2]]], [[[3]]]]]] ;
L = [[[[[[1]]]], [[[[2]]], [[[3]]]]]] ;
L = [[[[[[1]]], [[[2]]]]], [[[[[3]]]]]]
.....
*/

splitGen(L, R):- nat(N), splitN(N, L, R).
/*
?- splitGen([1,2,3], R).
R = [1, 2, 3] ;
R = [[1], [2], [3]] ;
R = [[1], [2, 3]] ;
R = [[1, 2], [3]] ;
R = [[1, 2, 3]] ;
R = [[[1]], [[2]], [[3]]] ;
R = [[[1]], [[2], [3]]] ;
R = [[[1], [2]], [[3]]] ;
R = [[[1], [2], [3]]] ;
R = [[[1]], [[2, 3]]] ;
R = [[[1], [2, 3]]] ;
R = [[[1, 2]], [[3]]] ;
R = [[[1, 2], [3]]] ;
R = [[[1, 2, 3]]] ;
....
*/

/*
   HW:
   1. Да се напише предикат binary(L), генериращ в L всички двоични дървета, като:
   - [] е двойчно дърво;
   - ако А и В са двойчни дървета, то и [A, B] е двойчно дърво.
   2. Да се дефинира предикат p(L, R), който генерира в R всички списъци с елемнти от L.
   3. Да се напише предикат p(N), генериращ ввсички числа от вида ai + bj:
   |a0 = 1						|b0 = 7
   |aN = 3*a(N - 1) + n 		|bN = 3b(N - 1) + n^2 - 1
   4. Да се напише предикат генериращ всички числа между 0 и 1000, които са от следния вид 8*(n+11)^5 * (19 + k)^2
   5. Да се напише предикат, които "пакетира" елементите в списък L. прим: [1,2,2,1,4,5,5,5] -> [[1], [2,2], [1], [4], [5,5,5]].
*/

% 1.
nat(0).
nat(N):- nat(M), N is M + 1.

between(A, B, A):- A =< B.
between(A, B, R):- A < B, A1 is A - 1, between(A1, B, R).

pairs(A, B):- nat(N), between(0, N, A), B is N - A.

binary(T):- nat(N), worker(N, T).

worker(0, []).
worker(N, [T1,T2]):- N > 0, N1 is N - 1, between(0, N1, NT1),
		NT2 is N1 - NT1, worker(NT1, T1), worker(NT2, T2).

% 2.
p(_, []).
p(L, [H|T]):- p(L, T), member(H, L). 

% 3.
a(0, 1).
a(N, R):- N > 0, N1 is N - 1, a(N1, R1), R is 3 * R1 + N.

b(0, 7).
b(N, R):- N > 0, N1 is N - 1, b(N1, R1), R is 3 * R1 + N^2 - 1.

p1(X):- pairs(A, B), a(A, R1), b(B, R2), X is R1 + R2.

% 4.
p2(X):- between(0, 1000, Y), between(0, 1000, Z), X is 8 * (Y + 11)^5 * (19 + Z)^2, X >= 0, X < 1000.

% 5.
pack([], []).
pack([A], [[A]]).
pack([A, A|T], [[A|C]|R]):- pack([A|T], [C|R]).
pack([B, A|T], [[B]|R]):- A \= B, pack([A|T], R).